<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hike Tracker</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- LeafletJS for maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        /* Custom styles for the app */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrolling of the whole page */
        }
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #map {
            flex-grow: 1; /* Map takes remaining space */
            background-color: #f0f0f0;
        }
        .leaflet-control-attribution, .leaflet-control-zoom {
            display: none; /* Hide default leaflet controls for a cleaner look */
        }
        .tab-content {
            height: calc(100vh - 4.5rem); /* Adjust based on nav height */
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100">

    <div id="app-container">
        <!-- Main Content -->
        <main class="flex-grow flex flex-col">
            <!-- Map View -->
            <div id="map-view" class="tab-content flex-grow flex flex-col">
                <div id="map" class="flex-grow"></div>
                
                 <!-- Location Status Indicator -->
                <div id="location-status" class="absolute top-4 left-1/2 -translate-x-1/2 z-[1000] bg-yellow-500 text-white px-4 py-2 rounded-full text-sm font-semibold shadow-lg hidden">
                    Waiting for location...
                </div>

                <!-- Floating Action Buttons on Map -->
                 <button id="recenter-btn" class="absolute top-20 right-4 z-[1000] bg-white p-3 rounded-full shadow-lg hover:bg-gray-100 transition-transform transform active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed">
                    <svg class="w-6 h-6 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
                </button>
                <div id="map-controls" class="absolute bottom-20 left-1/2 -translate-x-1/2 z-[1000] flex gap-4 p-2 bg-white/80 backdrop-blur-sm rounded-full shadow-lg">
                    <button id="start-btn" class="bg-green-500 text-white font-bold py-3 px-6 rounded-full shadow-md hover:bg-green-600 transition-transform transform active:scale-95">Start</button>
                    <button id="stop-btn" class="bg-red-500 text-white font-bold py-3 px-6 rounded-full shadow-md hover:bg-red-600 transition-transform transform active:scale-95 hidden">Finish</button>
                </div>
                <div id="recording-indicator" class="hidden absolute top-4 left-1/2 -translate-x-1/2 z-[1000] bg-red-500 text-white px-3 py-1 rounded-full text-sm font-semibold animate-pulse">
                    ● REC
                </div>
                 <div id="online-status" class="absolute top-4 right-4 z-[1000] px-3 py-1 rounded-full text-sm font-semibold flex items-center gap-2 bg-white/80 backdrop-blur-sm shadow">
                    <span id="status-indicator" class="w-3 h-3 rounded-full"></span>
                    <span id="status-text"></span>
                </div>
            </div>

            <!-- Past Hikes View -->
            <div id="hikes-view" class="tab-content p-4 bg-white hidden">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Past Hikes</h2>
                <div id="hikes-list" class="space-y-4">
                    <!-- Hikes will be dynamically inserted here -->
                </div>
                 <div id="hikes-loader" class="flex justify-center mt-8"><div class="loader"></div></div>
            </div>

            <!-- Statistics View -->
            <div id="stats-view" class="tab-content p-4 bg-white hidden">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Statistics</h2>
                 <div class="mb-4 border-b border-gray-200">
                    <nav class="flex space-x-4" aria-label="Tabs">
                        <button data-period="week" class="stats-period-btn text-gray-500 hover:text-gray-700 px-3 py-2 font-medium text-sm rounded-md">This Week</button>
                        <button data-period="month" class="stats-period-btn text-gray-500 hover:text-gray-700 px-3 py-2 font-medium text-sm rounded-md">This Month</button>
                        <button data-period="year" class="stats-period-btn text-gray-500 hover:text-gray-700 px-3 py-2 font-medium text-sm rounded-md">This Year</button>
                    </nav>
                </div>
                <div id="stats-content">
                    <!-- Stats will be dynamically inserted here -->
                </div>
                <div id="stats-loader" class="flex justify-center mt-8"><div class="loader"></div></div>

                <!-- Gemini Summary Section -->
                <div id="gemini-summary-container" class="mt-6 hidden">
                    <div class="flex justify-between items-center mb-2">
                         <h3 class="text-xl font-bold text-gray-800">✨ Your AI Summary</h3>
                         <button id="summarize-btn" class="bg-indigo-500 text-white font-semibold py-2 px-4 rounded-full shadow-md hover:bg-indigo-600 transition-transform transform active:scale-95 text-sm">
                            Generate
                         </button>
                    </div>
                    <div id="gemini-summary-loader" class="flex justify-center my-4 hidden"><div class="loader"></div></div>
                    <div id="gemini-summary-output" class="bg-indigo-50 border-l-4 border-indigo-400 p-4 rounded-r-lg text-indigo-800 italic">
                        <!-- Summary will be inserted here -->
                    </div>
                </div>
            </div>
        </main>
        
        <!-- Bottom Navigation Bar -->
        <nav class="bg-white shadow-t border-t border-gray-200 w-full">
            <div class="max-w-md mx-auto flex justify-around">
                <button data-tab="map" class="nav-btn flex-1 py-3 px-2 text-center text-blue-600">
                    <svg class="w-6 h-6 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                    <span class="text-xs">Map</span>
                </button>
                <button data-tab="hikes" class="nav-btn flex-1 py-3 px-2 text-center text-gray-500">
                    <svg class="w-6 h-6 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 012-2h2a2 2 0 012 2v6m-8-14v-2a2 2 0 012-2h4a2 2 0 012 2v2m-6 0h6"></path></svg>
                    <span class="text-xs">Hikes</span>
                </button>
                <button data-tab="stats" class="nav-btn flex-1 py-3 px-2 text-center text-gray-500">
                    <svg class="w-6 h-6 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 8v8m-4-5v5m-4-2v2"></path></svg>
                    <span class="text-xs">Stats</span>
                </button>
            </div>
        </nav>
    </div>

    <script type="module">
        // Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, enableIndexedDbPersistence, collection, doc, addDoc, setDoc, onSnapshot, query, serverTimestamp, getDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- CONFIG & GLOBAL STATE ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "AIza...", authDomain: "...", projectId: "..." };
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'hike-tracker-app';
        
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        let userId = null;
        let isRecording = false;
        let currentHikeId = null;
        let recordingWatchId = null;
        let trackPoints = [];
        let allHikes = [];
        let lastKnownPosition = null;

        // --- MAP STATE ---
        let map;
        let userMarker; // Used during recording (red)
        let currentLocationMarker; // Used when not recording (blue)
        let trackPolyline;
        let pastHikePolyline;

        // --- UI ELEMENTS ---
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const recordingIndicator = document.getElementById('recording-indicator');
        const locationStatusEl = document.getElementById('location-status');
        const recenterBtn = document.getElementById('recenter-btn');
        
        // --- INITIALIZATION ---
        enableIndexedDbPersistence(db).catch((err) => console.error("Firebase offline persistence failed", err.code));
        
        onAuthStateChanged(auth, (user) => {
            if (user) {
                userId = user.uid;
                console.log("User authenticated:", userId);
                initializeAppData();
            } else {
                signInAnonymously(auth).catch(error => console.error("Anonymous sign in failed:", error));
            }
        });
        
        function initMap() {
            map = L.map('map').setView([48.1351, 11.5820], 13); // Default to Munich
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);
            startContinuousLocationWatch();
        }
        initMap();

        function setupUIListeners() {
            document.querySelectorAll('.nav-btn').forEach(btn => btn.addEventListener('click', () => switchTab(btn.dataset.tab)));
            document.querySelectorAll('.stats-period-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                     document.querySelectorAll('.stats-period-btn').forEach(b => b.classList.remove('text-blue-600', 'border-blue-600', 'border-b-2'));
                     btn.classList.add('text-blue-600', 'border-blue-600', 'border-b-2');
                    renderStatistics(btn.dataset.period);
                });
            });
            startBtn.addEventListener('click', startRecording);
            stopBtn.addEventListener('click', stopRecording);
            document.getElementById('summarize-btn').addEventListener('click', handleSummarizeActivity);
            recenterBtn.addEventListener('click', () => {
                if (lastKnownPosition) {
                    map.setView([lastKnownPosition.lat, lastKnownPosition.lon], 16);
                }
            });
        }
        setupUIListeners();

        function initializeAppData() {
            if (!userId) return;
            listenToHikes();
        }
        
        // --- GEMINI API INTEGRATION ---
        async function callGemini(promptText) {
            const apiKey = ""; // Provided by the execution environment
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = { contents: [{ parts: [{ text: promptText }] }] };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API call failed with status ${response.status}`);
                const result = await response.json();
                const candidate = result.candidates?.[0];
                if (candidate?.content?.parts?.[0]?.text) {
                    return candidate.content.parts[0].text;
                }
                return "Sorry, I couldn't generate a response right now.";
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                return "An error occurred while contacting the AI assistant.";
            }
        }

        // --- CORE FUNCTIONALITY & LOCATION ---
        function startContinuousLocationWatch() {
            locationStatusEl.textContent = "Waiting for location...";
            locationStatusEl.classList.remove('hidden', 'bg-red-500');
            locationStatusEl.classList.add('bg-yellow-500');
            recenterBtn.disabled = true;

            navigator.geolocation.watchPosition(
                (pos) => {
                    locationStatusEl.classList.add('hidden');
                    recenterBtn.disabled = false;
                    
                    const { latitude, longitude } = pos.coords;
                    lastKnownPosition = { lat: latitude, lon: longitude };

                    if (!isRecording) {
                        updateCurrentLocationMarker(latitude, longitude);
                    }
                },
                (err) => {
                    recenterBtn.disabled = true;
                    locationStatusEl.classList.remove('hidden', 'bg-yellow-500');
                    locationStatusEl.classList.add('bg-red-500');
                    switch(err.code) {
                        case err.PERMISSION_DENIED:
                            locationStatusEl.textContent = "Location access denied.";
                            break;
                        case err.POSITION_UNAVAILABLE:
                            locationStatusEl.textContent = "Location information is unavailable.";
                            break;
                        case err.TIMEOUT:
                            locationStatusEl.textContent = "Location request timed out.";
                            break;
                        default:
                            locationStatusEl.textContent = "An unknown error occurred.";
                            break;
                    }
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }

        function updateCurrentLocationMarker(lat, lon) {
             if (!currentLocationMarker) {
                currentLocationMarker = L.circleMarker([lat, lon], {
                    radius: 8,
                    color: 'white',
                    weight: 2,
                    fillColor: '#3B82F6', // Blue color
                    fillOpacity: 1
                }).addTo(map);
                map.setView([lat, lon], 16); // Center on first location found
            } else {
                currentLocationMarker.setLatLng([lat, lon]);
            }
        }

        async function startRecording() {
            if (isRecording) return;
            isRecording = true;
            trackPoints = [];
            
            if (pastHikePolyline) map.removeLayer(pastHikePolyline);
            pastHikePolyline = null;
            if(currentLocationMarker) map.removeLayer(currentLocationMarker);
            currentLocationMarker = null;

            startBtn.classList.add('hidden');
            stopBtn.classList.remove('hidden');
            recordingIndicator.classList.remove('hidden');

            try {
                const hikeRef = await addDoc(collection(db, `/artifacts/${appId}/users/${userId}/hikes`), { 
                    name: "", 
                    startTime: serverTimestamp(),
                    endTime: null,
                    distance: 0,
                    duration: 0,
                    elevationGain: 0,
                    status: 'recording' 
                });
                currentHikeId = hikeRef.id;
                recordingWatchId = navigator.geolocation.watchPosition(handlePositionUpdateForRecording, handlePositionError, { enableHighAccuracy: true });
            } catch (error) {
                console.error("Error starting hike:", error);
                isRecording = false;
            }
        }
        
        async function stopRecording() {
            if (!isRecording) return;
            navigator.geolocation.clearWatch(recordingWatchId);
            isRecording = false;
            recordingWatchId = null;

            stopBtn.classList.add('hidden');
            startBtn.classList.remove('hidden');
            recordingIndicator.classList.add('hidden');
            
            // Re-enable the blue current location marker
            if (lastKnownPosition) {
                updateCurrentLocationMarker(lastKnownPosition.lat, lastKnownPosition.lon);
            }

            const finalDistance = calculateTotalDistance(trackPoints);
            const finalDuration = trackPoints.length > 1 ? (trackPoints[trackPoints.length - 1].timestamp - trackPoints[0].timestamp) / 1000 : 0;
            
            const distanceToSend = !isNaN(finalDistance) ? finalDistance : 0;
            const durationToSend = !isNaN(finalDuration) ? finalDuration : 0;

            const hikeRef = doc(db, `/artifacts/${appId}/users/${userId}/hikes/${currentHikeId}`);
            try {
                await setDoc(hikeRef, { 
                    endTime: serverTimestamp(), 
                    distance: distanceToSend, 
                    duration: durationToSend, 
                    status: 'completed' 
                }, { merge: true });

                if (userMarker) map.removeLayer(userMarker);
                if (trackPolyline) map.removeLayer(trackPolyline);
                userMarker = null;
                trackPolyline = null;

                correctElevation(currentHikeId, [...trackPoints]);
            } catch (error) {
                console.error("Error finishing hike:", error);
            } finally {
                 currentHikeId = null;
            }
        }

        function handlePositionUpdateForRecording(pos) {
            const { latitude, longitude, altitude } = pos.coords;
            const latlng = [latitude, longitude];
            const pointData = { lat: latitude, lon: longitude, alt: altitude, timestamp: Date.now() };
            trackPoints.push(pointData);

            if (!userMarker) userMarker = L.circleMarker(latlng, { radius: 8, color: 'white', fillColor: '#EF4444', fillOpacity: 1 }).addTo(map);
            else userMarker.setLatLng(latlng);
            map.setView(latlng, map.getZoom());

            const latlngs = trackPoints.map(p => [p.lat, p.lon]);
            if (!trackPolyline) trackPolyline = L.polyline(latlngs, { color: '#EF4444', weight: 4 }).addTo(map);
            else trackPolyline.setLatLngs(latlngs);
            
            if (currentHikeId) addDoc(collection(db, `/artifacts/${appId}/users/${userId}/hikes/${currentHikeId}/track`), pointData);
        }

        function handlePositionError(err) { console.warn(`Geolocation Error (${err.code}): ${err.message}`); }

        // --- DATA HANDLING, RENDERING, and other functions remain the same ---
        function listenToHikes() {
            const hikesQuery = query(collection(db, `/artifacts/${appId}/users/${userId}/hikes`));
            onSnapshot(hikesQuery, (snapshot) => {
                document.getElementById('hikes-loader').style.display = 'none';
                document.getElementById('stats-loader').style.display = 'none';
                allHikes = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                allHikes.sort((a, b) => (b.startTime?.toMillis() || 0) - (a.startTime?.toMillis() || 0));
                renderHikesList();
                const selectedPeriod = document.querySelector('.stats-period-btn.text-blue-600')?.dataset.period || 'week';
                renderStatistics(selectedPeriod);
            }, (error) => console.error("Error listening to hikes:", error));
        }
        
        function renderHikesList() {
            const listEl = document.getElementById('hikes-list');
            if (allHikes.length === 0) {
                listEl.innerHTML = `<p class="text-gray-500">You haven't recorded any hikes yet. Start one from the Map tab!</p>`;
                return;
            }
            listEl.innerHTML = allHikes.map(hike => `
                <div class="border rounded-lg p-4 bg-gray-50" data-hike-container-id="${hike.id}">
                    <div class="flex justify-between items-start">
                        <div>
                            <input type="text" value="${hike.name || ''}" placeholder="Untitled Hike" class="hike-name-input font-bold text-lg text-gray-800 bg-transparent border-b-2 border-transparent focus:border-blue-500 focus:outline-none w-full mb-1" data-hike-id="${hike.id}">
                            <div class="text-xs text-gray-500">${formatDate(hike.startTime)}</div>
                        </div>
                        <div class="text-sm ${hike.status === 'completed' ? 'text-green-600 bg-green-100' : 'text-blue-600 bg-blue-100'} px-2 py-1 rounded-full flex-shrink-0">${hike.status}</div>
                    </div>
                    <div class="mt-3 grid grid-cols-3 gap-2 text-center">
                        <div><div class="text-sm text-gray-500">Distance</div><div class="font-semibold">${(hike.distance || 0).toFixed(2)} km</div></div>
                        <div><div class="text-sm text-gray-500">Duration</div><div class="font-semibold">${formatDuration(hike.duration || 0)}</div></div>
                        <div><div class="text-sm text-gray-500">Elevation</div><div class="font-semibold">${hike.elevationGain ? `${hike.elevationGain.toFixed(0)} m` : 'N/A'}</div></div>
                    </div>
                    <div class="mt-3 pt-3 border-t border-gray-200 flex items-center justify-between gap-2">
                         <button class="show-on-map-btn text-sm text-blue-600 hover:underline" data-hike-id="${hike.id}">Show on Map</button>
                        ${hike.status === 'completed' ? `
                        <div class="flex items-center gap-2">
                            <button class="suggest-name-btn bg-purple-500 text-white text-xs font-semibold py-1 px-3 rounded-full hover:bg-purple-600" data-hike-id="${hike.id}">✨ Suggest Name</button>
                            <button class="save-name-btn bg-gray-200 text-gray-700 text-xs font-semibold py-1 px-3 rounded-full hover:bg-gray-300" data-hike-id="${hike.id}">Save</button>
                        </div>` : ''}
                    </div>
                </div>
            `).join('');
            
            listEl.querySelectorAll('.show-on-map-btn').forEach(el => el.addEventListener('click', () => showHikeOnMap(el.dataset.hikeId)));
            listEl.querySelectorAll('.suggest-name-btn').forEach(btn => btn.addEventListener('click', handleSuggestName));
            listEl.querySelectorAll('.save-name-btn').forEach(btn => btn.addEventListener('click', (e) => {
                const hikeId = e.target.dataset.hikeId;
                const input = listEl.querySelector(`.hike-name-input[data-hike-id="${hikeId}"]`);
                updateHikeName(hikeId, input.value);
                e.target.textContent = 'Saved!';
                setTimeout(() => { e.target.textContent = 'Save'; }, 2000);
            }));
        }

        async function handleSuggestName(e) {
            const btn = e.target;
            const hikeId = btn.dataset.hikeId;
            const hike = allHikes.find(h => h.id === hikeId);
            if (!hike) return;

            btn.disabled = true;
            btn.innerHTML = `<span class="inline-block w-3 h-3 border-2 border-white border-t-transparent rounded-full animate-spin"></span>`;

            const prompt = `Generate a short, creative name (3-5 words max) for a hike with these stats: ${hike.distance.toFixed(1)} km, duration ${formatDuration(hike.duration)}, and ${hike.elevationGain.toFixed(0)}m elevation gain. Keep it inspiring or descriptive.`;
            const suggestedName = await callGemini(prompt);
            
            const input = document.querySelector(`.hike-name-input[data-hike-id="${hikeId}"]`);
            if (input) input.value = suggestedName.replace(/["\.]/g, '').trim();

            btn.disabled = false;
            btn.innerHTML = '✨ Suggest Name';
        }

        async function updateHikeName(hikeId, newName) {
            const hikeRef = doc(db, `/artifacts/${appId}/users/${userId}/hikes/${hikeId}`);
            try { await setDoc(hikeRef, { name: newName }, { merge: true }); }
            catch (error) { console.error("Error updating hike name:", error); }
        }

        async function showHikeOnMap(hikeId) {
            switchTab('map');
            if (pastHikePolyline) map.removeLayer(pastHikePolyline);
            try {
                const trackSnapshot = await getDocs(collection(db, `/artifacts/${appId}/users/${userId}/hikes/${hikeId}/track`));
                const points = trackSnapshot.docs.map(d => d.data()).sort((a,b) => a.timestamp - b.timestamp);
                const latlngs = points.map(p => [p.lat, p.lon]);
                if (latlngs.length > 0) {
                    pastHikePolyline = L.polyline(latlngs, { color: '#8B5CF6', weight: 4 }).addTo(map);
                    map.fitBounds(pastHikePolyline.getBounds());
                }
            } catch (error) { console.error("Failed to load hike track:", error); }
        }
        
        function renderStatistics(period) {
            const statsContent = document.getElementById('stats-content');
            if (allHikes.length === 0) {
                statsContent.innerHTML = `<p class="text-gray-500">No data available for statistics.</p>`;
                return;
            }

            const now = new Date();
            let startDate;
            if (period === 'week') startDate = new Date(now.setDate(now.getDate() - now.getDay() + (now.getDay() === 0 ? -6 : 1)));
            else if (period === 'month') startDate = new Date(now.getFullYear(), now.getMonth(), 1);
            else startDate = new Date(now.getFullYear(), 0, 1);
            startDate.setHours(0, 0, 0, 0);

            const filteredHikes = allHikes.filter(h => h.startTime?.toDate() >= startDate && h.status === 'completed');
            const totalDistance = filteredHikes.reduce((sum, h) => sum + (h.distance || 0), 0);
            const totalDuration = filteredHikes.reduce((sum, h) => sum + (h.duration || 0), 0);
            const totalElevation = filteredHikes.reduce((sum, h) => sum + (h.elevationGain || 0), 0);
            const hikeCount = filteredHikes.length;
            
            statsContent.innerHTML = `
                <div class="grid grid-cols-2 gap-4">
                    <div class="bg-blue-50 p-4 rounded-lg"><div class="text-sm text-blue-800">Total Hikes</div><div class="text-3xl font-bold text-blue-900">${hikeCount}</div></div>
                    <div class="bg-green-50 p-4 rounded-lg"><div class="text-sm text-green-800">Total Distance</div><div class="text-3xl font-bold text-green-900">${totalDistance.toFixed(2)} km</div></div>
                    <div class="bg-yellow-50 p-4 rounded-lg"><div class="text-sm text-yellow-800">Total Duration</div><div class="text-3xl font-bold text-yellow-900">${formatDuration(totalDuration)}</div></div>
                    <div class="bg-purple-50 p-4 rounded-lg"><div class="text-sm text-purple-800">Total Elevation</div><div class="text-3xl font-bold text-purple-900">${totalElevation.toFixed(0)} m</div></div>
                </div>`;
            
            const summaryContainer = document.getElementById('gemini-summary-container');
            if (hikeCount > 0) {
                summaryContainer.classList.remove('hidden');
                Object.assign(summaryContainer.dataset, { hikeCount, totalDistance: totalDistance.toFixed(2), totalDuration, totalElevation: totalElevation.toFixed(0), period });
            } else {
                summaryContainer.classList.add('hidden');
            }
        }

        async function handleSummarizeActivity() {
            const container = document.getElementById('gemini-summary-container');
            const loader = document.getElementById('gemini-summary-loader');
            const output = document.getElementById('gemini-summary-output');
            const btn = document.getElementById('summarize-btn');
            const { hikeCount, totalDistance, totalDuration, totalElevation, period } = container.dataset;

            if (!hikeCount || hikeCount === '0') return;
            
            loader.classList.remove('hidden');
            output.classList.add('hidden');
            btn.disabled = true;

            const prompt = `I'm a user of a hiking app. Generate a short, motivational summary of my hiking activity for this ${period}. Stats: ${hikeCount} hikes, ${totalDistance} km total distance, ${formatDuration(totalDuration)} total duration, ${totalElevation} meters total elevation gain. Keep it 2-4 sentences, address me as "you", and be positive and encouraging.`;
            const summaryText = await callGemini(prompt);
            
            output.innerHTML = summaryText.replace(/\n/g, '<br>');
            loader.classList.add('hidden');
            output.classList.remove('hidden');
            btn.disabled = false;
        }

        // --- UTILITY & HELPER FUNCTIONS ---
        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.add('hidden'));
            document.getElementById(`${tabId}-view`).classList.remove('hidden');
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('text-blue-600');
                btn.classList.add('text-gray-500');
            });
            document.querySelector(`.nav-btn[data-tab="${tabId}"]`).classList.add('text-blue-600');
            if (tabId === 'stats') {
                 document.querySelector('.stats-period-btn[data-period="week"]').click();
                 document.getElementById('gemini-summary-output').innerHTML = 'Click "Generate" to get an AI-powered overview of your activity.';
            }
        }
        function calculateTotalDistance(points) {
            let total = 0;
            for (let i = 1; i < points.length; i++) total += haversineDistance(points[i-1], points[i]);
            return total;
        }
        function haversineDistance(c1, c2) {
            const R = 6371, toRad = x => x * Math.PI / 180;
            const dLat = toRad(c2.lat - c1.lat), dLon = toRad(c2.lon - c1.lon);
            const a = Math.sin(dLat/2)**2 + Math.cos(toRad(c1.lat)) * Math.cos(toRad(c2.lat)) * Math.sin(dLon/2)**2; 
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }
        function formatDate(ts) {
            return ts?.toDate().toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' }) || 'N/A';
        }
        function formatDuration(s) {
            if (s < 60) return `${Math.round(s)}s`;
            return `${s > 3600 ? Math.floor(s/3600) + 'h ' : ''}${Math.floor((s % 3600) / 60)}m`;
        }
        function updateOnlineStatus() {
            const isOnline = navigator.onLine;
            document.getElementById('status-indicator').className = `w-3 h-3 rounded-full ${isOnline ? 'bg-green-500' : 'bg-gray-400'}`;
            document.getElementById('status-text').textContent = isOnline ? 'Online' : 'Offline';
            document.getElementById('status-text').classList.toggle('text-green-700', isOnline);
            document.getElementById('status-text').classList.toggle('text-gray-500', !isOnline);
        }
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);
        updateOnlineStatus();

        // --- ELEVATION CORRECTION ---
        async function correctElevation(hikeId, points) {
            if (!navigator.onLine || points.length === 0) return;
            const locations = points.map(p => ({ latitude: p.lat, longitude: p.lon }));
            const CHUNK_SIZE = 100;
            let correctedElevations = [];
            try {
                for (let i = 0; i < locations.length; i += CHUNK_SIZE) {
                    const chunk = locations.slice(i, i + CHUNK_SIZE);
                    const response = await fetch('https://api.opentopodata.org/v1/eudem25m', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ locations: chunk })
                    });
                    if (!response.ok) throw new Error(`API error: ${response.statusText}`);
                    correctedElevations.push(...(await response.json()).results.map(r => r.elevation));
                }
                let elevationGain = 0;
                for (let i = 1; i < correctedElevations.length; i++) {
                    const diff = correctedElevations[i] - correctedElevations[i-1];
                    if (diff > 0) elevationGain += diff;
                }
                await setDoc(doc(db, `/artifacts/${appId}/users/${userId}/hikes/${hikeId}`), { elevationGain }, { merge: true });
            } catch (error) { console.error("Elevation correction failed:", error); }
        }
    </script>
</body>
</html>
